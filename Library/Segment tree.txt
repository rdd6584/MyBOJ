#include<stdio.h>

int val[16777217];

int size = 1;
int su;
int n, m, k, or;

void init(int temp){
	if(temp < size){
		init(temp * 2);
		init(temp * 2 + 1);
		val[temp] = val[temp * 2] + val[temp * 2 + 1];
	}
}

void update(int i, int data){ // add data to the segment. Notice i is a index in the tree.
	val[i] -= data;
	while(i > 1){
		i /= 2;
		val[i] -= data;
	}
}

int find(int temp, int le, int ri, int tl, int tr){ // Sum(le ~ ri)
	int sum = 0;
	if(tl >= le && tr <= ri) return val[temp];
	if(tl > ri || tr < le) return 0;
	
	sum += find(temp * 2, le, ri, tl, (tl + tr) / 2);
	return sum + find(temp * 2 + 1, le, ri, (tl + tr) / 2 + 1, tr);
}

int search(int temp){ // find x in (sum(1~x) == temp). faster than bin search
	if(val[temp] + su < k) {
		su += val[temp];
		search(temp + 1);
	}
	
	else if(temp >= size) {
		update(temp, -1);
		return temp - size + 1;
	}
	
	else search(temp * 2);
}

int main(){

	scanf("%d %d %d", &n, &m, &or);
	int last = n, kk = n, tt;
	
	while(size < n) size *= 2;
	
	for(int i = 0; i < n; i++)
		val[i + size] = 1;
		
	init(1);
	
	while(kk){
		su = 0;
		k = m % kk;
		if(k == 0) k = kk;
		
		su = -1 * (find(1, 1, last, 1, size));
		
		if(su + val[1] < k) su += val[1];
		
		last = search(1);
		if(last == or) printf("%d", n-kk+1);
		
		kk--;
	}
}
