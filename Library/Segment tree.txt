#include<stdio.h>

int tree[16777217];

int size = 1;
int su;
int n, m, k, or;

void init(int temp){
	if(temp < size){
		init(temp * 2);
		init(temp * 2 + 1);
		tree[temp] = tree[temp * 2] + tree[temp * 2 + 1];
	}
}

void add(int i, int val){ // add val to the segment. Notice i is a index in the tree.
	tree[i] += val;
	while(i > 1){
		i /= 2;
		tree[i] += val;
	}
}

void update(int i, int val){
	tree[i] = val;
	while(i > 1){
		i /= 2;
		tree[i] = tree[i * 2] + tree[i * 2 + 1];
	}
}

int find(int temp, int le, int ri, int tl, int tr){ // Sum(le ~ ri)
	int sum = 0;
	if(tl >= le && tr <= ri) return tree[temp];
	if(tl > ri || tr < le) return 0;
	
	sum += find(temp * 2, le, ri, tl, (tl + tr) / 2);
	return sum + find(temp * 2 + 1, le, ri, (tl + tr) / 2 + 1, tr);
}

int search(int temp){ // find x in (sum(1~x) == temp). faster than bin search
	if(tree[temp] + su < k) {
		su += tree[temp];
		search(temp + 1);
	}
	
	else if(temp >= size) {
		update(temp, -1);
		return temp - size + 1;
	}
	
	else search(temp * 2);
}

int main(){

	scanf("%d %d %d", &n, &m, &or);
	int last = n, kk = n, tt;
	
	while(size < n) size *= 2;
	
	for(int i = 0; i < n; i++)
		tree[i + size] = 1;
		
	init(1);
	
	while(kk){
		su = 0;
		k = m % kk;
		if(k == 0) k = kk;
		
		su = -1 * (find(1, 1, last, 1, size));
		
		if(su + tree[1] < k) su += tree[1];
		
		last = search(1);
		if(last == or) printf("%d", n-kk+1);
		
		kk--;
	}
}
